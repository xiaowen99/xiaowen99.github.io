<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构-线性结构-数组</title>
      <link href="/2022/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-线性结构-数组"><a href="#数据结构-线性结构-数组" class="headerlink" title="数据结构-线性结构-数组"></a>数据结构-线性结构-数组</h1><h2 id="集合、列表、数组定义"><a href="#集合、列表、数组定义" class="headerlink" title="集合、列表、数组定义"></a>集合、列表、数组定义</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>​    由一个或多个确定的元素所构成的整体。通俗来讲，集合就是将一组事物组合在一起。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>集合里的元素类型不一定相同</li><li>集合里的元素没有顺序</li></ol><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>​    是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。</p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ol><li>有限</li><li>有序</li><li>长度可变</li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>​    数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。</p><p>​    正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的一些特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如 C++ 和 Java 中，数组中的元素类型必须保持一致，而 Python 中则可以不同。Python 中的数组叫做 list，具有更多的高级功能。</p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>​    数组会用一些名为 <code>索引</code> 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 <code>0</code> 算起的。我们可以根据数组中的索引，快速访问数组中的元素。<img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163908.png" alt="4.png"></p><p>​    而列表中没有索引，这是数组与列表最大的不同点。</p><p>​    其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。要理解这一点，我们需要了解数组在内存中的存储方式，我们将在下一节中详细介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163941.png" alt="5.png"></p><p>​    相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。</p><h2 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h2><h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><p>​    读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 0 开始。</p><p>​    在计算机中，内存可以看成一些已经排列好的格子，每个格子对应一个内存地址。一般情况下，数据会分散地存储在不同的格子中。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164026.png" alt="1.png"></p><p>​    而对于数组，计算机会在内存中为其申请一段 连续 的空间，并且会记下索引为 0 处的内存地址。以数组 [“C”, “O”, “D”, “E”, “R”] 为例，它的各元素对应的索引及内存地址如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164054.png" alt="2.png"></p><p>假如我们想要访问索引为 2 处的元素 “D” 时，计算机会进行以下计算：</p><ol><li>找到该数组的索引 0 的内存地址： 2008；</li><li>将内存地址加上索引值，作为目标元素的地址，即 2008 + 2 &#x3D; 2010，对应的元素为 “D”，这时便找到了目标元素。</li></ol><p>我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 O(1)</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>假如我们对数组中包含哪些元素并不了解，只是想知道其中是否含有元素 “E”，数组会如何查找元素 &#96;”E” 呢？</p><p>​    与读取元素类似，由于我们只保存了索引为 0 处的内存地址，因此在查找元素时，只需从数组开头逐步向后查找就可以了。如果数组中的某个元素为目标元素，则停止查找；否则继续搜索直到到达数组的末尾<img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163045.png" alt="4.gif"></p><p>发现，最坏情况下，搜索的元素为 “R”，或者数组中不包含目标元素时，我们需要查找 n 次，n 为数组的长度，因此查找元素的时间复杂度为 O(N)</p><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>假如我们想在原有的数组中再插入一个元素 “S” 呢？</p><p>​    如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。<img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163222.png" alt="6.gif"></p><p>​    然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置 腾出 空间，然后进行插入操作。比如，我们想要在索引 2 处插入 “S”。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163431.png" alt="7.gif"></p><p>​    发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一种数据结构，即链表可以有效解决这个问题。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>​    删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 空缺 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 填补 操作。</p><p>以删除索引 1 中的元素 “O” 为例，具体过程如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163536.png" alt="6.gif"></p><p>​    当数组的长度为 n 时，最坏情况下，我们删除第一个元素，共需要的步骤数为 1 + (n - 1) &#x3D; n 步，其中，1 为删除操作，n - 1 为移动其余元素的步骤数。删除操作具有线性时间复杂度，即时间复杂度为 O(N)，N 为数组的长度。</p><h2 id="LeetCode题练习"><a href="#LeetCode题练习" class="headerlink" title="LeetCode题练习"></a>LeetCode题练习</h2><h3 id="寻找数组中心索引"><a href="#寻找数组中心索引" class="headerlink" title="寻找数组中心索引"></a>寻找数组中心索引</h3><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p><p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum - nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            <span class="keyword">if</span> (leftNum == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            leftNum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据库概述</title>
      <link href="/2022/03/27/MySQL%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/03/27/MySQL%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础-数据库概述"><a href="#MySQL基础-数据库概述" class="headerlink" title="MySQL基础-数据库概述"></a>MySQL基础-数据库概述</h1><h2 id="为什么用数据库"><a href="#为什么用数据库" class="headerlink" title="为什么用数据库"></a>为什么用数据库</h2><ol><li><p>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企</p><p>业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多</p><p>通过各种关系数据库来完成。</p></li><li><p>持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数</p><p>据文件中。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328120129.png" alt="数据库展示"></p><h2 id="数据库与数据库管理系统"><a href="#数据库与数据库管理系统" class="headerlink" title="数据库与数据库管理系统"></a>数据库与数据库管理系统</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="DB：数据库（Database）"><a href="#DB：数据库（Database）" class="headerlink" title="DB：数据库（Database）"></a>DB：数据库（Database）</h4><p>​    存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</p><h4 id="DBMS：数据库管理系统（Database-Management-System）"><a href="#DBMS：数据库管理系统（Database-Management-System）" class="headerlink" title="DBMS：数据库管理系统（Database Management System）"></a>DBMS：数据库管理系统（Database Management System）</h4><p>​    是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控</p><p>制。用户通过数据库管理系统访问数据库中表内的数据。</p><h4 id="SQL：结构化查询语言（Structured-Query-Language）"><a href="#SQL：结构化查询语言（Structured-Query-Language）" class="headerlink" title="SQL：结构化查询语言（Structured Query Language）"></a>SQL：结构化查询语言（Structured Query Language）</h4><p>​    专门用来与数据库通信的语言。</p><h3 id="数据库与数据库管理系统的关系"><a href="#数据库与数据库管理系统的关系" class="headerlink" title="数据库与数据库管理系统的关系"></a>数据库与数据库管理系统的关系</h3><p>​    数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存</p><p>应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p><p>数据库管理系统、数据库和表的关系如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328120706.png" alt="关系图"></p><h3 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h3><h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><p>1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气</p><p>越来越大，公司也改名叫 Oracle 公司。</p><p>2007年，总计85亿美金收购BEA Systems。 </p><p>2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了</p><p>MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。</p><p>2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。</p><p>如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。</p><h4 id="SQLserver"><a href="#SQLserver" class="headerlink" title="SQLserver"></a>SQLserver</h4><p>SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集</p><p>成，也可以很好地与Microsoft BackOffice产品集成。</p><h4 id="DB-2"><a href="#DB-2" class="headerlink" title="DB 2"></a>DB 2</h4><p>IBM公司的数据库产品,收费的。常应用在银行系统中。</p><h4 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h4><p>PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以</p><p>及SQL处理较快。</p><h4 id="SQlite"><a href="#SQlite" class="headerlink" title="SQlite"></a>SQlite</h4><p>嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置</p><p>数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。</p><h4 id="informix"><a href="#informix" class="headerlink" title="informix"></a>informix</h4><p>IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行</p><p>于unix&#x2F;linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证</p><p>券系统的应用。</p><h2 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h2><p>MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着</p><p>应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、</p><p>易维护、易扩展的需求，促进了MySQL的长足发展。</p><h3 id="MySQL8-0"><a href="#MySQL8-0" class="headerlink" title="MySQL8.0"></a>MySQL8.0</h3><p>MySQL从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上</p><p>做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化</p><p>器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><h3 id="选择MySQL原因"><a href="#选择MySQL原因" class="headerlink" title="选择MySQL原因"></a>选择MySQL原因</h3><ol><li>开放源代码，使用成本低。</li><li>性能卓越，服务稳定。</li><li>软件体积小，使用简单，并且易于维护。</li><li>历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。</li><li>许多互联网公司在用，经过了时间的验证。</li></ol><h2 id="RDBMS-与-非RDBMS"><a href="#RDBMS-与-非RDBMS" class="headerlink" title="RDBMS 与 非RDBMS"></a>RDBMS 与 非RDBMS</h2><p>关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、 </p><p>MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。</p><h3 id="关系型数据库-RDBMS"><a href="#关系型数据库-RDBMS" class="headerlink" title="关系型数据库(RDBMS)"></a>关系型数据库(RDBMS)</h3><p>​    这种类型的数据库是 最古老 的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系 （即二维表格形式）。</p><p>​    关系型数据库以 行(row) 和 列(column) 的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table) ，一组表组成了一个库(database)</p><p>​    SQL 就是关系型数据库的查询语言。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328122134.png"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>复杂查询 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>事务支持 使得对于安全性能很高的数据访问要求得以实现。</li></ol><h3 id="非关系型数据库-非RDBMS"><a href="#非关系型数据库-非RDBMS" class="headerlink" title="非关系型数据库(非RDBMS)"></a>非关系型数据库(非RDBMS)</h3><p>​    非关系型数据库，可看成传统关系型数据库的功能 阉割版本 ，基于键值对存储数据，不需要经过SQL层的解析， 性能非常高 。同时，通过减少不常用的功能，进一步提高性能。</p><p>​    目前基本上大部分主流的非关系型数据库都是免费的。</p><h4 id="键值型数据库"><a href="#键值型数据库" class="headerlink" title="键值型数据库"></a>键值型数据库</h4><p>​    键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。</p><p>​    键值型数据库典型的使用场景是作为 内存缓存 。 Redis 是最流行的键值型数据库。</p><h4 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h4><p>​    此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB是最流行的文档型数据库。此外，还有CouchDB等。</p><h4 id="搜索引擎数据库"><a href="#搜索引擎数据库" class="headerlink" title="搜索引擎数据库"></a>搜索引擎数据库</h4><p>​    虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。</p><p>典型产品：Solr、Elasticsearch、Splunk 等。</p><h4 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h4><p>​    列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I&#x2F;O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</p><h4 id="图形数据库"><a href="#图形数据库" class="headerlink" title="图形数据库"></a>图形数据库</h4><p>​    图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p><p>​    图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。</p><h2 id="关系型数据库涉及规则"><a href="#关系型数据库涉及规则" class="headerlink" title="关系型数据库涉及规则"></a>关系型数据库涉及规则</h2><ol><li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。</li></ol><h3 id="表、记录、字段"><a href="#表、记录、字段" class="headerlink" title="表、记录、字段"></a>表、记录、字段</h3><ol><li>E-R（entity-relationship，实体-联系）模型中有三个主要概念是： 实体集 、 属性 、 联系集 。</li><li>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328123020.png"></p><h3 id="表的关联关系"><a href="#表的关联关系" class="headerlink" title="表的关联关系"></a>表的关联关系</h3><ol><li><p>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用</p><p>关系模型来表示。</p></li><li><p>四种：一对一关联、一对多关联、多对多关联、自我引用.</p><p></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法--稀疏数组</title>
      <link href="/2022/03/27/%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/27/%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="算法-–稀疏数组"><a href="#算法-–稀疏数组" class="headerlink" title="算法 –稀疏数组"></a>算法 –稀疏数组</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>编写五子棋盘，实现IO存盘，可以将数据写入到存盘中（IO读写不实操）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>五子棋盘可以转化为二维数组，0 代表空位 1代表白棋，2 代表黑棋</li><li>二维数组中存在大量 0 ，这是无意义数据，所以采用稀疏数组进行压缩</li><li>稀疏数组压缩好处，减小存储，减少IO，提高效率</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327150042.png" alt="稀疏数组"></p><p>准备：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建原始数组</span></span><br><span class="line">      <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">      <span class="comment">// 有效数据</span></span><br><span class="line">      arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">      arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">      arr[<span class="number">3</span>][<span class="number">4</span>] =<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span>[] ints : arr) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">              System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327152959.png" alt="棋盘数组"></p><h3 id="二维数组转换为稀疏数组"><a href="#二维数组转换为稀疏数组" class="headerlink" title="二维数组转换为稀疏数组"></a>二维数组转换为稀疏数组</h3><p>思路：</p><ol><li>遍历原始数组得到有效数据个数sum。</li><li>根据sum创建稀疏数组大小</li><li>将有效数据存入到稀疏数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建稀疏数组</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1.先遍历二维数组，得到非零数据的个数</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) sum ++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.创建稀疏数组</span></span><br><span class="line">     <span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">     <span class="comment">// 记录原数组初始规模,有效数据个数</span></span><br><span class="line">     sparseArr[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">     sparseArr[<span class="number">0</span>][<span class="number">1</span>] = arr.length;</span><br><span class="line">     sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     flag:</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                 count ++;</span><br><span class="line">                 sparseArr[count][<span class="number">0</span>] =i;</span><br><span class="line">                 sparseArr[count][<span class="number">1</span>] =j;</span><br><span class="line">                 sparseArr[count][<span class="number">2</span>] =arr[i][j];</span><br><span class="line">                 <span class="keyword">if</span> (count == (sum + <span class="number">1</span>))&#123;</span><br><span class="line">                     <span class="keyword">break</span> flag;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327153156.png" alt="稀疏数组"></p><h3 id="稀疏数组转化为原始数组"><a href="#稀疏数组转化为原始数组" class="headerlink" title="稀疏数组转化为原始数组"></a>稀疏数组转化为原始数组</h3><p>思路：</p><ol><li>先读取稀疏数组第一行，根据第一行数据，创建原始二维数组</li><li>在读取稀疏数组后几行数据，并赋给原始数组对应位置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏数组转换为原始数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据稀疏数组第一行创建原始数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把数据还原到chessArr</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327154153.png" alt="还原棋盘数组"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原始数组</span></span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        <span class="comment">// 有效数据</span></span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">4</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建稀疏数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.先遍历二维数组，得到非零数据的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) sum ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.创建稀疏数组</span></span><br><span class="line">        <span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 记录原数组初始规模,有效数据个数</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = arr.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        flag:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] =i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] =j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] =arr[i][j];</span><br><span class="line">                    <span class="keyword">if</span> (count == (sum + <span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">break</span> flag;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出得到的稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.println(sparseArr[i][<span class="number">0</span>] + <span class="string">&quot;\t&quot;</span> + sparseArr[i][<span class="number">1</span>] + <span class="string">&quot;\t&quot;</span> + sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稀疏数组转换为原始数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据稀疏数组第一行创建原始数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把数据还原到chessArr</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出还原后的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个文章</title>
      <link href="/2022/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/"/>
      <url>/2022/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h1><p>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊</p><h2 id="dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊"><a href="#dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊" class="headerlink" title="dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊"></a>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊</h2><p>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊</p><h3 id="fawejk"><a href="#fawejk" class="headerlink" title="fawejk"></a>fawejk</h3>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/26/hello-world/"/>
      <url>/2022/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
