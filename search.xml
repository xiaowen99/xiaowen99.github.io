<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL第十一章-数据处理之增删改</title>
      <link href="/2022/03/31/MySQL%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/"/>
      <url>/2022/03/31/MySQL%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="第十一章–数据处理之增删改"><a href="#第十一章–数据处理之增删改" class="headerlink" title="第十一章–数据处理之增删改"></a>第十一章–数据处理之增删改</h1><h2 id="预备"><a href="#预备" class="headerlink" title="预备"></a>预备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">USE atguigudb;</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS emp1(</span><br><span class="line">id INT,</span><br><span class="line">`name` VARCHAR(15),</span><br><span class="line">hire_date DATE,</span><br><span class="line">salary DOUBLE(10,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC emp1;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM emp1;</span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220331095535.png"></p><p>解决方式：使用 INSERT 语句向表中插入数据</p><h3 id="方式一：VALUES的方式添加"><a href="#方式一：VALUES的方式添加" class="headerlink" title="方式一：VALUES的方式添加"></a>方式一：VALUES的方式添加</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 使用这种语法一次只能向表中插入一条数据。</span><br><span class="line"></span><br><span class="line"># ① 没有指明添加的字段</span><br><span class="line">#正确的</span><br><span class="line">INSERT INTO emp1</span><br><span class="line">VALUES (1,&#x27;Tom&#x27;,&#x27;2000-12-21&#x27;,3400); #注意：一定要按照声明的字段的先后顺序添加</span><br><span class="line"></span><br><span class="line"># ② 指明要添加的字段 （推荐）</span><br><span class="line">INSERT INTO emp1(id,hire_date,salary,`name`)</span><br><span class="line">VALUES(2,&#x27;1999-09-09&#x27;,4000,&#x27;Jerry&#x27;);</span><br><span class="line"></span><br><span class="line"># 说明：没有进行赋值的hire_date 的值为 null</span><br><span class="line">INSERT INTO emp1(id,salary,`name`)</span><br><span class="line">VALUES(3,4500,&#x27;shk&#x27;);</span><br><span class="line"></span><br><span class="line"># ③ 同时插入多条记录 </span><br><span class="line"></span><br><span class="line">INSERT INTO emp1</span><br><span class="line">VALUES</span><br><span class="line">(4,&#x27;Jim&#x27;,&#x27;2000-5-1&#x27;),</span><br><span class="line">(5,&#x27;张俊杰&#x27;,&#x27;2020-1-1&#x27;);</span><br><span class="line"># 推荐</span><br><span class="line">INSERT INTO emp1(id,NAME,salary)</span><br><span class="line">VALUES</span><br><span class="line">(4,&#x27;Jim&#x27;,5000),</span><br><span class="line">(5,&#x27;张俊杰&#x27;,5500);</span><br></pre></td></tr></table></figure><p>使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含义如下：</p><p> ●　Records：表明插入的记录条数。 </p><p>●　Duplicates：表明插入时被忽略的记录，原因可能是这些记录包含了重复的主键值。 </p><p>●　Warnings：表明有问题的数据值，例如发生数据类型转换。</p><p>一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中 效率更高 。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。</p><p>VALUES 也可以写成 VALUE ，但是VALUES是标准写法。</p><h3 id="方式2：将查询结果插入到表中"><a href="#方式2：将查询结果插入到表中" class="headerlink" title="方式2：将查询结果插入到表中"></a>方式2：将查询结果插入到表中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM emp1;</span><br><span class="line"></span><br><span class="line">INSERT INTO emp1(id,NAME,salary,hire_date)</span><br><span class="line">#查询语句</span><br><span class="line">SELECT employee_id,last_name,salary,hire_date  # 查询的字段一定要与添加到的表的字段一一对应</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id IN (70,60);</span><br><span class="line"></span><br><span class="line">DESC emp1;</span><br><span class="line">DESC employees;</span><br><span class="line"></span><br><span class="line">#说明：emp1表中要添加数据的字段的长度不能低于employees表中查询的字段的长度。</span><br><span class="line"># 如果emp1表中要添加数据的字段的长度低于employees表中查询的字段的长度的话，就有添加不成功的风险。</span><br></pre></td></tr></table></figure><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220331103427.png"></p><p>可以一次更新多条数据。</p><p>如果需要回滚数据，需要保证在DML前，进行设置：SET AUTOCOMMIT &#x3D; FALSE;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># UPDATE .... SET .... WHERE ...</span><br><span class="line"># 可以实现批量修改数据的。</span><br><span class="line"># 如果没有where，会修改整个字段的数据</span><br><span class="line"></span><br><span class="line">UPDATE emp1</span><br><span class="line">SET hire_date = CURDATE()</span><br><span class="line">WHERE id = 5;</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp1;</span><br><span class="line"></span><br><span class="line">#同时修改一条数据的多个字段</span><br><span class="line">UPDATE emp1</span><br><span class="line">SET hire_date = CURDATE(),salary = 6000</span><br><span class="line">WHERE id = 4;</span><br><span class="line"></span><br><span class="line">#题目：将表中姓名中包含字符a的提薪20%</span><br><span class="line">UPDATE emp1</span><br><span class="line">SET salary = salary * 1.2</span><br><span class="line">WHERE NAME LIKE &#x27;%a%&#x27;;</span><br><span class="line"></span><br><span class="line">#修改数据时，是可能存在不成功的情况的。（可能是由于约束的影响造成的）</span><br><span class="line">UPDATE employees</span><br><span class="line">SET department_id = 10000</span><br><span class="line">WHERE employee_id = 102;</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#3. 删除数据 DELETE FROM .... WHERE....</span><br><span class="line"></span><br><span class="line">DELETE FROM emp1</span><br><span class="line">WHERE id = 1;</span><br><span class="line"></span><br><span class="line">#在删除数据时，也有可能因为约束的影响，导致删除失败</span><br><span class="line">DELETE FROM departments</span><br><span class="line">WHERE department_id = 50;</span><br><span class="line"></span><br><span class="line">#小结：DML操作默认情况下，执行完以后都会自动提交数据。</span><br><span class="line"># 如果希望执行完以后不自动提交数据，则需要使用 SET autocommit = FALSE</span><br></pre></td></tr></table></figure><h2 id="MySQL8新特性：计算列"><a href="#MySQL8新特性：计算列" class="headerlink" title="MySQL8新特性：计算列"></a>MySQL8新特性：计算列</h2><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。</p><p>在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。</p><p>举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。 首先创建测试表tb1，语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USE atguigudb;</span><br><span class="line"></span><br><span class="line">CREATE TABLE test1(</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line">c INT GENERATED ALWAYS AS (a + b) VIRTUAL  #字段c即为计算列</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test1(a,b)</span><br><span class="line">VALUES(10,20);</span><br><span class="line"></span><br><span class="line">SELECT * FROM test1;</span><br><span class="line"></span><br><span class="line">UPDATE test1</span><br><span class="line">SET a = 100;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL第十章-创建和管理</title>
      <link href="/2022/03/29/MySQL%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86/"/>
      <url>/2022/03/29/MySQL%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第十章–创建和管理"><a href="#第十章–创建和管理" class="headerlink" title="第十章–创建和管理"></a>第十章–创建和管理</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据的存储过程"><a href="#数据的存储过程" class="headerlink" title="数据的存储过程"></a>数据的存储过程</h3><p>存储数据是处理数据的第一步 。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。</p><p>那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？ 在 MySQL 中，一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220329154805.png"></p><p>我们要先创建一个数据库，而不是直接创建数据表呢？</p><p>因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是 数据库服务器 、 数据库 、 数据表 、数据表的 行与列 。 </p><p>MySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。</p><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ol><li>数据库名、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li><li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220329155817.png"></p><p>其中，常用的几类类型介绍如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220329155916.png"></p><h2 id="创建和管理数据库"><a href="#创建和管理数据库" class="headerlink" title="创建和管理数据库"></a>创建和管理数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方式1：创建数据库</span><br><span class="line">CREATE DATABASE 数据库名;</span><br><span class="line"># 方式2：创建数据库并指定字符集</span><br><span class="line">CREATE DATABASE 数据库名 CHARACTER SET 字符集;</span><br><span class="line"># 方式3：判断数据库是否已经存在，不存在则创建数据库（ 推荐 ）</span><br><span class="line">CREATE DATABASE IF NOT EXISTS 数据库名;</span><br></pre></td></tr></table></figure><p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p><p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。(成本比较大)</p><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前所有的数据库</span><br><span class="line">SHOW DATABASES; #有一个S，代表多个数据库</span><br><span class="line"># 查看当前正在使用的数据库</span><br><span class="line">SELECT DATABASE(); #使用的一个 mysql 中的全局函数</span><br><span class="line"># 查看指定库下所有的表</span><br><span class="line">SHOW TABLES FROM 数据库名;</span><br><span class="line"># 查看数据库的创建信息</span><br><span class="line">SHOW CREATE DATABASE 数据库名;</span><br><span class="line">SHOW CREATE DATABASE 数据库名\G；</span><br><span class="line"># 使用/切换数据库</span><br><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。 </p><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE 数据库名 CHARACTER SET 字符集; #比如：gbk、utf8等 </span><br></pre></td></tr></table></figure><p>注意：一般情况下不要修改数据库，成本大</p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式1：删除指定的数据库</span><br><span class="line">DROP DATABASE 数据库名;</span><br><span class="line"># 方式2：删除指定的数据库（ 推荐 ）</span><br><span class="line">DROP DATABASE IF EXISTS 数据库名;</span><br></pre></td></tr></table></figure><p>注意：本博主只教怎么删库，可没教你删库跑路，慎重啊，道友们！文明使用数据库！</p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><h3 id="创建方式一"><a href="#创建方式一" class="headerlink" title="创建方式一"></a>创建方式一</h3><h4 id="具备条件"><a href="#具备条件" class="headerlink" title="具备条件"></a>具备条件</h4><ol><li>CREATE TABLE权限</li><li>存储空间</li></ol><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] 表名( </span><br><span class="line">  字段1, 数据类型 [约束条件] [默认值], </span><br><span class="line">  字段2, 数据类型 [约束条件] [默认值], </span><br><span class="line">  字段3, 数据类型 [约束条件] [默认值], </span><br><span class="line">  ……[表约束条件] </span><br><span class="line">);</span><br><span class="line"># 加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</span><br></pre></td></tr></table></figure><h4 id="必须指定："><a href="#必须指定：" class="headerlink" title="必须指定："></a>必须指定：</h4><ol><li>表名</li><li>列名(或字段名)，数据类型，长度</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 举例</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">-- int类型 </span><br><span class="line">  emp_id INT,</span><br><span class="line">-- 最多保存20个中英文字符 </span><br><span class="line">  emp_name VARCHAR(20),</span><br><span class="line">-- 总位数不超过15位 </span><br><span class="line">  salary DOUBLE,</span><br><span class="line">-- 日期类型 </span><br><span class="line">  birthday DATE </span><br><span class="line">);</span><br><span class="line">DESC emp; # 查看表结构</span><br><span class="line">show CREATE TABLE emp; # 如果创建表的时候没有指明编码格式，默认匹配数据库的编码格式</span><br></pre></td></tr></table></figure><p>MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。</p><h3 id="创建方式二"><a href="#创建方式二" class="headerlink" title="创建方式二"></a>创建方式二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#方式2：基于现有的表，同时导入数据,（用查询的一切数据创建表 =&gt; 包括查出表名和查出的数据）</span><br><span class="line">CREATE TABLE myemp2</span><br><span class="line">AS</span><br><span class="line">SELECT employee_id,last_name,salary</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">DESC myemp2;</span><br><span class="line">DESC employees;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM myemp2;</span><br><span class="line"></span><br><span class="line">#说明1：查询语句中字段的别名，可以作为新创建的表的字段的名称。</span><br><span class="line">#说明2：此时的查询语句可以结构比较丰富，使用前面章节讲过的各种SELECT</span><br><span class="line">CREATE TABLE myemp3</span><br><span class="line">AS</span><br><span class="line">SELECT e.employee_id emp_id,e.last_name lname,d.department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.department_id = d.department_id;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM myemp3;</span><br><span class="line"></span><br><span class="line">DESC myemp3;</span><br><span class="line"></span><br><span class="line">#练习1：创建一个表employees_copy，实现对employees表的复制，包括表数据</span><br><span class="line">CREATE TABLE employees_copy</span><br><span class="line">AS</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees_copy;</span><br><span class="line"></span><br><span class="line">#练习2：创建一个表employees_blank，实现对employees表的复制，不包括表数据</span><br><span class="line">CREATE TABLE employees_blank</span><br><span class="line">AS</span><br><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">#where department_id &gt; 10000;</span><br><span class="line">WHERE 1 = 2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM employees_blank;</span><br></pre></td></tr></table></figure><h3 id="查看数据表结构"><a href="#查看数据表结构" class="headerlink" title="查看数据表结构"></a>查看数据表结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DESC emp; # 查看表结构</span><br><span class="line">SHOW CREATE TABLE 表名\G</span><br><span class="line"># 使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220329191901.png"></p><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><h3 id="追加一个列"><a href="#追加一个列" class="headerlink" title="追加一个列"></a>追加一个列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 </span><br><span class="line">ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】;</span><br><span class="line"></span><br><span class="line"># 3.1 添加一个字段</span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">ADD salary DOUBLE(10,2); #默认添加到表中的最后一个字段的位置</span><br><span class="line"></span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">ADD phone_number VARCHAR(20) FIRST; # 在表首行添加</span><br><span class="line"></span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">ADD email VARCHAR(45) AFTER emp_name;# 在emp_name后添加</span><br></pre></td></tr></table></figure><h3 id="修改一个列"><a href="#修改一个列" class="headerlink" title="修改一个列"></a>修改一个列</h3><p>可以修改列的数据类型，长度、默认值和位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 </span><br><span class="line">MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名 2】;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3.2 修改一个字段：数据类型、长度、默认值（略）</span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">MODIFY emp_name VARCHAR(25) ;</span><br><span class="line"></span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">MODIFY emp_name VARCHAR(35) DEFAULT &#x27;aaa&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对默认值的修改只影响今后对表的修改</p><p>此外，还可以通过此种方式修改列的约束</p><h3 id="重命名一个列"><a href="#重命名一个列" class="headerlink" title="重命名一个列"></a>重命名一个列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 </span><br><span class="line">CHANGE 【column】 列名 新列名 新数据类型;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3.3 重命名一个字段</span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">CHANGE salary monthly_salary DOUBLE(10,2);</span><br><span class="line"></span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">CHANGE email my_email VARCHAR(50);</span><br></pre></td></tr></table></figure><h3 id="删除一个列"><a href="#删除一个列" class="headerlink" title="删除一个列"></a>删除一个列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 </span><br><span class="line">DROP 【COLUMN】字段名</span><br><span class="line"># 3.4 删除一个字段</span><br><span class="line">ALTER TABLE myemp1</span><br><span class="line">DROP COLUMN my_email;</span><br></pre></td></tr></table></figure><h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 方式一</span><br><span class="line">RENAME TABLE emp TO myemp;</span><br><span class="line"></span><br><span class="line">RENAME TABLE myemp1</span><br><span class="line">TO myemp11;</span><br><span class="line"></span><br><span class="line">DESC myemp11;</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">ALTER table dept </span><br><span class="line">RENAME [TO] detail_dept;</span><br><span class="line"></span><br><span class="line">RENAME TABLE myemp1</span><br><span class="line">TO myemp11;</span><br><span class="line"></span><br><span class="line">DESC myemp11;</span><br></pre></td></tr></table></figure><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><ol><li>在MySQL中，当一张数据表 没有与其他任何数据表形成关联关系 时，可以将当前数据表直接删除。</li><li>数据和结构都被删除</li><li>所有正在运行的相关事务被提交</li><li>所有相关索引被删除</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];</span><br><span class="line"></span><br><span class="line">DROP TABLE dept80;</span><br><span class="line"></span><br><span class="line">#不光将表结构删除掉，同时表中的数据也删除掉，释放表空间</span><br><span class="line">DROP TABLE IF EXISTS myemp2;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS myemp12;</span><br></pre></td></tr></table></figure><p>IF EXISTS 的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p><h2 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#清空表，表示清空表中的所有数据，但是表结构保留。</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees_copy;</span><br><span class="line"></span><br><span class="line">TRUNCATE TABLE employees_copy;</span><br><span class="line"></span><br><span class="line">SELECT * FROM employees_copy;</span><br><span class="line"></span><br><span class="line">DESC employees_copy;</span><br></pre></td></tr></table></figure><p>阿里开发规范：</p><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。</p><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p><h2 id="内容扩展"><a href="#内容扩展" class="headerlink" title="内容扩展"></a>内容扩展</h2><h3 id="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"><a href="#拓展1：阿里巴巴《Java开发手册》之MySQL字段命名" class="headerlink" title="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"></a>拓展1：阿里巴巴《Java开发手册》之MySQL字段命名</h3><p>【 强制 】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><p>正例：aliyun_admin，rdc_config，level3_name</p><p>反例：AliyunAdmin，rdcConfig，level_3_name </p><p>【 强制 】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p><p>【 强制 】表必备三字段：id, gmt_create, gmt_modified。</p><p>说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被</p><p>动式更新</p><p>【 推荐 】表的命名最好是遵循 “业务名称_表的作用”。</p><p>正例：alipay_task 、 force_project、 trade_config </p><p>【 推荐 】库名与应用名称尽量一致。</p><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p><p>正例：无符号值可以避免误存负数，且扩大了表示范围。</p><h3 id="拓展2：如何理解清空表，删除表等操作需谨慎"><a href="#拓展2：如何理解清空表，删除表等操作需谨慎" class="headerlink" title="拓展2：如何理解清空表，删除表等操作需谨慎"></a>拓展2：如何理解清空表，删除表等操作需谨慎</h3><p>​    表删除 操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行 备份 ，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p><p>​    同样的，在使用 ALTER TABLE 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的 备份 ，因为数据库的改变是 无法撤销 的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p><h3 id="拓展3：MySQL8新特性—DDL的原子化"><a href="#拓展3：MySQL8新特性—DDL的原子化" class="headerlink" title="拓展3：MySQL8新特性—DDL的原子化"></a>拓展3：MySQL8新特性—DDL的原子化</h3><p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即 DDL操作要么成功要么回滚 。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE mytest; </span><br><span class="line"></span><br><span class="line">USE mytest; </span><br><span class="line"></span><br><span class="line">CREATE TABLE book1( </span><br><span class="line">  book_id INT , </span><br><span class="line">  book_name VARCHAR(255) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW TABLES;</span><br><span class="line"># 在MySQL 5.7版本中，测试步骤如下： 删除数据表book1和数据表book2，</span><br><span class="line">DROP TABLE book1,book2;</span><br><span class="line"># 从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。</span><br><span class="line"># 但是在8.0版本后，book1没有被删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#7. DCL 中 COMMIT 和 ROLLBACK</span><br><span class="line"># COMMIT:提交数据。一旦执行COMMIT，则数据就被永久的保存在了数据库中，意味着数据不可以回滚。</span><br><span class="line"># ROLLBACK:回滚数据。一旦执行ROLLBACK,则可以实现数据的回滚。回滚到最近的一次COMMIT之后。</span><br><span class="line"></span><br><span class="line">#8. 对比 TRUNCATE TABLE 和 DELETE FROM </span><br><span class="line"># 相同点：都可以实现对表中所有数据的删除，同时保留表结构。</span><br><span class="line"># 不同点：</span><br><span class="line">#TRUNCATE TABLE：一旦执行此操作，表数据全部清除。同时，数据是不可以回滚的。</span><br><span class="line">#DELETE FROM：一旦执行此操作，表数据可以全部清除（不带WHERE）。同时，数据是可以实现回滚的。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">9. DDL 和 DML 的说明</span><br><span class="line">  ① DDL的操作一旦执行，就不可回滚。指令SET autocommit = FALSE对DDL操作失效。(因为在执行完DDL</span><br><span class="line">    操作之后，一定会执行一次COMMIT。而此COMMIT操作不受SET autocommit = FALSE影响的。)</span><br><span class="line">  </span><br><span class="line">  ② DML的操作默认情况，一旦执行，也是不可回滚的。但是，如果在执行DML之前，执行了 </span><br><span class="line">    SET autocommit = FALSE，则执行的DML操作就可以实现回滚。</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"># 演示：DELETE FROM </span><br><span class="line">#1)</span><br><span class="line">COMMIT;</span><br><span class="line">#2)</span><br><span class="line">SELECT *</span><br><span class="line">FROM myemp3;</span><br><span class="line">#3)</span><br><span class="line">SET autocommit = FALSE;</span><br><span class="line">#4)</span><br><span class="line">DELETE FROM myemp3;</span><br><span class="line">#5)</span><br><span class="line">SELECT *</span><br><span class="line">FROM myemp3;</span><br><span class="line">#6)</span><br><span class="line">ROLLBACK;</span><br><span class="line">#7)</span><br><span class="line">SELECT *</span><br><span class="line">FROM myemp3;</span><br><span class="line"></span><br><span class="line"># 演示：TRUNCATE TABLE</span><br><span class="line">#1)</span><br><span class="line">COMMIT;</span><br><span class="line">#2)</span><br><span class="line">SELECT *</span><br><span class="line">FROM myemp3;</span><br><span class="line">#3)</span><br><span class="line">SET autocommit = FALSE;</span><br><span class="line">#4)</span><br><span class="line">TRUNCATE TABLE myemp3;</span><br><span class="line">#5)</span><br><span class="line">SELECT *</span><br><span class="line">FROM myemp3;</span><br><span class="line">#6)</span><br><span class="line">ROLLBACK;</span><br><span class="line">#7)</span><br><span class="line">SELECT *</span><br><span class="line">FROM myemp3;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL第九章--子查询</title>
      <link href="/2022/03/28/MySQL%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/03/28/MySQL%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="第九章–子查询"><a href="#第九章–子查询" class="headerlink" title="第九章–子查询"></a>第九章–子查询</h1><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。</p><p>SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p><h2 id="需求分析和问题解决"><a href="#需求分析和问题解决" class="headerlink" title="需求分析和问题解决"></a>需求分析和问题解决</h2><h3 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328185428.png" alt="1"></p><p>现有解决方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#方式一： </span><br><span class="line">SELECT salary </span><br><span class="line">FROM employees </span><br><span class="line">WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT last_name,salary </span><br><span class="line">FROM employees </span><br><span class="line">WHERE salary &gt; 11000; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#方式二：自连接 </span><br><span class="line">SELECT e2.last_name,e2.salary </span><br><span class="line">FROM employees e1,employees e2 </span><br><span class="line">WHERE e1.last_name = &#x27;Abel&#x27; </span><br><span class="line">AND e1.`salary` &lt; e2.`salary`</span><br><span class="line"></span><br><span class="line">#方式三：子查询</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name =&#x27;Abel&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="子查询的基本使用"><a href="#子查询的基本使用" class="headerlink" title="子查询的基本使用"></a>子查询的基本使用</h3><h4 id="子查询的基本语法结构："><a href="#子查询的基本语法结构：" class="headerlink" title="子查询的基本语法结构："></a>子查询的基本语法结构：</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328191316.png" alt="1"></p><p>子查询（内查询）在主查询之前一次执行完成。</p><p>子查询的结果被主查询（外查询）使用。</p><p><strong>注意事项</strong></p><ol><li>子查询要包含在括号内</li><li>将子查询放在比较条件的右侧</li><li>单行操作符对应单行子查询，多行操作符对应多行子查询</li></ol><h3 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h3><h4 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328192609.png"></p><p>查询出一个结果供外查询使用</p><h4 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328192749.png"></p><p>查询出多个结果供给外查询使用</p><h4 id="相关（关联）子查询"><a href="#相关（关联）子查询" class="headerlink" title="相关（关联）子查询"></a>相关（关联）子查询</h4><h4 id="不相关（或非关联）子查询"><a href="#不相关（或非关联）子查询" class="headerlink" title="不相关（或非关联）子查询"></a>不相关（或非关联）子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name =&#x27;Abel&#x27;</span><br><span class="line">);</span><br><span class="line"># 外查询每次查询都只跟内查询的查询结果做比较，内查询的查询结果就只需要查询一次，这就是一次非关联子查询</span><br></pre></td></tr></table></figure><h2 id="单行子查询-1"><a href="#单行子查询-1" class="headerlink" title="单行子查询"></a>单行子查询</h2><h3 id="单行子查询比较操作符"><a href="#单行子查询比较操作符" class="headerlink" title="单行子查询比较操作符"></a>单行子查询比较操作符</h3><table><thead><tr><th align="center">操作符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">equal to</td></tr><tr><td align="center">&gt;</td><td align="center">greater than</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">greater than or equal to</td></tr><tr><td align="center">&lt;</td><td align="center">less than</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">less than or equal to</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">not equal to</td></tr></tbody></table><h3 id="例子代码示范"><a href="#例子代码示范" class="headerlink" title="例子代码示范"></a>例子代码示范</h3><h4 id="题目：查询工资大于149号员工工资的员工的信息"><a href="#题目：查询工资大于149号员工工资的员工的信息" class="headerlink" title="题目：查询工资大于149号员工工资的员工的信息"></a>题目：查询工资大于149号员工工资的员工的信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">                SELECT salary</span><br><span class="line">                FROM employees</span><br><span class="line">                WHERE employee_id = 149</span><br><span class="line">                );</span><br></pre></td></tr></table></figure><h4 id="题目：返回job-id与141号员工相同，salary比143号员工多的员工姓名，job-id和工资"><a href="#题目：返回job-id与141号员工相同，salary比143号员工多的员工姓名，job-id和工资" class="headerlink" title="题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资"></a>题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary = (</span><br><span class="line">              SELECT MIN(salary)</span><br><span class="line">              FROM employees</span><br><span class="line">             );</span><br></pre></td></tr></table></figure><h4 id="题目：-HAVNING语句中-查询最低工资大于50号部门最低工资的部门id和其最低工资"><a href="#题目：-HAVNING语句中-查询最低工资大于50号部门最低工资的部门id和其最低工资" class="headerlink" title="题目：(HAVNING语句中)查询最低工资大于50号部门最低工资的部门id和其最低工资"></a>题目：(HAVNING语句中)查询最低工资大于50号部门最低工资的部门id和其最低工资</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id, MIN(salary) </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">HAVING MIN(salary) &gt; (</span><br><span class="line">                      SELECT MIN(salary) </span><br><span class="line">  FROM employees </span><br><span class="line">  WHERE department_id = 50</span><br><span class="line">                      );</span><br></pre></td></tr></table></figure><h4 id="题目：-case中-显式员工的employee-id-last-name和location。其中，若员工department-id与location-id为1800的department-id相同，则location为’Canada’，其余则为’USA’。"><a href="#题目：-case中-显式员工的employee-id-last-name和location。其中，若员工department-id与location-id为1800的department-id相同，则location为’Canada’，其余则为’USA’。" class="headerlink" title="题目：(case中)显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。"></a>题目：(case中)显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id, last_name, (CASE department_id WHEN (SELECT department_id FROM departments WHERE location_id = 1800) THEN &#x27;Canada&#x27; ELSE &#x27;USA&#x27; END) location FROM employees;</span><br></pre></td></tr></table></figure><h4 id="题目：子查询中的空值问题"><a href="#题目：子查询中的空值问题" class="headerlink" title="题目：子查询中的空值问题"></a>题目：子查询中的空值问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, job_id </span><br><span class="line">FROM employees </span><br><span class="line">WHERE job_id = (</span><br><span class="line">              SELECT job_id </span><br><span class="line">              FROM employees </span><br><span class="line">              WHERE last_name = &#x27;Haas&#x27;</span><br><span class="line">              );</span><br><span class="line"># 子查询结果为null，所以跟主查询任何值跟null比较都为null，所以没有数据</span><br></pre></td></tr></table></figure><h2 id="多行子查询-1"><a href="#多行子查询-1" class="headerlink" title="多行子查询"></a>多行子查询</h2><p>也称为集合比较子查询</p><p>内查询返回多行</p><p>使用多行比较操作符</p><h3 id="多行子查询操作符"><a href="#多行子查询操作符" class="headerlink" title="多行子查询操作符"></a>多行子查询操作符</h3><table><thead><tr><th align="center">操作符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">IN</td><td align="center">等于列表中的任意一个</td></tr><tr><td align="center">ANY</td><td align="center">需要和单行比较操作符一起使用，和子查询返回的某一个值比较</td></tr><tr><td align="center">ALL</td><td align="center">需要和单行比较操作符一起使用，和子查询返回的所有值比较</td></tr><tr><td align="center">SOME</td><td align="center">实际上是ANY的别名，作用相同，一般常使用ANY</td></tr></tbody></table><h3 id="例子代码示范-1"><a href="#例子代码示范-1" class="headerlink" title="例子代码示范"></a>例子代码示范</h3><h4 id="题目：返回其它job-id中比job-id为‘IT-PROG’部门任一工资低的员工的员工号、姓名、job-id-以及salary"><a href="#题目：返回其它job-id中比job-id为‘IT-PROG’部门任一工资低的员工的员工号、姓名、job-id-以及salary" class="headerlink" title="题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary"></a>题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &lt; ANY(</span><br><span class="line">                  SELECT salary</span><br><span class="line">                  FROM employees</span><br><span class="line">                  WHERE job_id = &#x27;IT_PROG&#x27;</span><br><span class="line">                  )</span><br><span class="line">AND job_id &lt;&gt; &#x27;IT_PROG&#x27;;</span><br></pre></td></tr></table></figure><h4 id="题目：返回其它job-id中比job-id为‘IT-PROG’部门所有工资低的员工的员工号、姓名、job-id-以及salary"><a href="#题目：返回其它job-id中比job-id为‘IT-PROG’部门所有工资低的员工的员工号、姓名、job-id-以及salary" class="headerlink" title="题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资低的员工的员工号、姓名、job_id 以及salary"></a>题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资低的员工的员工号、姓名、job_id 以及salary</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &lt; ALL(</span><br><span class="line">                  SELECT salary</span><br><span class="line">                  FROM employees</span><br><span class="line">                  WHERE job_id = &#x27;IT_PROG&#x27;</span><br><span class="line">                  )</span><br><span class="line">AND job_id &lt;&gt; &#x27;IT_PROG&#x27;;</span><br></pre></td></tr></table></figure><h4 id="题目：查询平均工资最低的部门id"><a href="#题目：查询平均工资最低的部门id" class="headerlink" title="题目：查询平均工资最低的部门id"></a>题目：查询平均工资最低的部门id</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) = (</span><br><span class="line">                      SELECT MIN(avg_sal)</span><br><span class="line">                      FROM (</span><br><span class="line">                            SELECT AVG(salary) avg_sal</span><br><span class="line">                            FROM employees</span><br><span class="line">                            GROUP BY department_id</span><br><span class="line">                            ) dept_avg_sal</span><br><span class="line">);</span><br><span class="line"># from 后面写子查询，相当于重新建了一张表，表只有一列数据，只有一个字段 avg_sal</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) &lt;=ALL(</span><br><span class="line">                        SELECT AVG(salary) avg_sal</span><br><span class="line">                        FROM employees</span><br><span class="line">                        GROUP BY department_id</span><br><span class="line">                        );</span><br></pre></td></tr></table></figure><h4 id="题目：多查询中的空值问题"><a href="#题目：多查询中的空值问题" class="headerlink" title="题目：多查询中的空值问题"></a>题目：多查询中的空值问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name </span><br><span class="line">FROM employees </span><br><span class="line">WHERE employee_id NOT IN ( </span><br><span class="line">                          SELECT manager_id </span><br><span class="line">                          FROM employees </span><br><span class="line">                          );</span><br></pre></td></tr></table></figure><h2 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h2><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。</p><p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220329083432.png"></p><h3 id="例子代码示范-2"><a href="#例子代码示范-2" class="headerlink" title="例子代码示范"></a>例子代码示范</h3><h4 id="题目：查询员工中工资大于本部门平均工资的员工的last-name-salary和其department-id"><a href="#题目：查询员工中工资大于本部门平均工资的员工的last-name-salary和其department-id" class="headerlink" title="题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id"></a>题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</h4><h5 id="方式一：相关子查询"><a href="#方式一：相关子查询" class="headerlink" title="方式一：相关子查询"></a>方式一：相关子查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salary,department_id</span><br><span class="line">FROM employees e1</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">SELECT AVG(salary)</span><br><span class="line">FROM employees e2</span><br><span class="line">WHERE e1.department_id = e2.department_id</span><br><span class="line">) </span><br></pre></td></tr></table></figure><h5 id="方式二：在-FROM-中使用子查询"><a href="#方式二：在-FROM-中使用子查询" class="headerlink" title="方式二：在 FROM 中使用子查询"></a>方式二：在 FROM 中使用子查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.last_name,e.salary,e.department_id</span><br><span class="line">FROM employees e,(</span><br><span class="line">SELECT AVG(salary) avg_sal ,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">) t_dept_avg_sal</span><br><span class="line">WHERE e.department_id = t_dept_avg_sal.department_id</span><br><span class="line">AND e.salary = t_dept_avg_sal.avg_sal;</span><br></pre></td></tr></table></figure><h4 id="题目：查询员工的id-salary-按照department-name-排序"><a href="#题目：查询员工的id-salary-按照department-name-排序" class="headerlink" title="题目：查询员工的id,salary,按照department_name 排序"></a>题目：查询员工的id,salary,按照department_name 排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.employee_id,e.salary</span><br><span class="line">FROM employees e</span><br><span class="line">GROUP BY (</span><br><span class="line">SELECT department_name</span><br><span class="line">FROM departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="EXISTS-与-NOT-EXISTS关键字"><a href="#EXISTS-与-NOT-EXISTS关键字" class="headerlink" title="EXISTS 与 NOT EXISTS关键字"></a>EXISTS 与 NOT EXISTS关键字</h3><p>​    关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行</p><p>​    如果在子查询中不存在满足条件的行：</p><p>​        条件返回 FALSE</p><p>​        继续在子查询中查找</p><p>​    如果在子查询中存在满足条件的行：</p><p>​        不在子查询中继续查找</p><p>​        条件返回 TRUE </p><p>​    NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</p><h4 id="题目：查询公司管理者的employee-id，last-name，job-id，department-id信息"><a href="#题目：查询公司管理者的employee-id，last-name，job-id，department-id信息" class="headerlink" title="题目：查询公司管理者的employee_id，last_name，job_id，department_id信息"></a>题目：查询公司管理者的employee_id，last_name，job_id，department_id信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id, last_name, job_id, department_id </span><br><span class="line">FROM employees e1 </span><br><span class="line">WHERE EXISTS ( </span><br><span class="line">            SELECT * </span><br><span class="line">            FROM employees e2 </span><br><span class="line">            WHERE e2.manager_id = e1.employee_id</span><br><span class="line">          );</span><br></pre></td></tr></table></figure><h3 id="子查询与自连接"><a href="#子查询与自连接" class="headerlink" title="子查询与自连接"></a>子查询与自连接</h3><p>自连接方式好！</p><p>题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。</p><p>可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题--搜索插入位置</title>
      <link href="/2022/03/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2022/03/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题--寻找数组的中心索引</title>
      <link href="/2022/03/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/03/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="寻找数组中心索引"><a href="#寻找数组中心索引" class="headerlink" title="寻找数组中心索引"></a>寻找数组中心索引</h1><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p><p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum - nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            <span class="keyword">if</span> (leftNum == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            leftNum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性结构-数组</title>
      <link href="/2022/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-线性结构-数组"><a href="#数据结构-线性结构-数组" class="headerlink" title="数据结构-线性结构-数组"></a>数据结构-线性结构-数组</h1><h2 id="集合、列表、数组定义"><a href="#集合、列表、数组定义" class="headerlink" title="集合、列表、数组定义"></a>集合、列表、数组定义</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>​    由一个或多个确定的元素所构成的整体。通俗来讲，集合就是将一组事物组合在一起。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>集合里的元素类型不一定相同</li><li>集合里的元素没有顺序</li></ol><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>​    是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。</p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ol><li>有限</li><li>有序</li><li>长度可变</li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>​    数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。</p><p>​    正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的一些特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如 C++ 和 Java 中，数组中的元素类型必须保持一致，而 Python 中则可以不同。Python 中的数组叫做 list，具有更多的高级功能。</p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>​    数组会用一些名为 <code>索引</code> 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 <code>0</code> 算起的。我们可以根据数组中的索引，快速访问数组中的元素。<img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163908.png" alt="4.png"></p><p>​    而列表中没有索引，这是数组与列表最大的不同点。</p><p>​    其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。要理解这一点，我们需要了解数组在内存中的存储方式，我们将在下一节中详细介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163941.png" alt="5.png"></p><p>​    相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。</p><h2 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h2><h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><p>​    读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 0 开始。</p><p>​    在计算机中，内存可以看成一些已经排列好的格子，每个格子对应一个内存地址。一般情况下，数据会分散地存储在不同的格子中。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164026.png" alt="1.png"></p><p>​    而对于数组，计算机会在内存中为其申请一段 连续 的空间，并且会记下索引为 0 处的内存地址。以数组 [“C”, “O”, “D”, “E”, “R”] 为例，它的各元素对应的索引及内存地址如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164054.png" alt="2.png"></p><p>假如我们想要访问索引为 2 处的元素 “D” 时，计算机会进行以下计算：</p><ol><li>找到该数组的索引 0 的内存地址： 2008；</li><li>将内存地址加上索引值，作为目标元素的地址，即 2008 + 2 &#x3D; 2010，对应的元素为 “D”，这时便找到了目标元素。</li></ol><p>我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 O(1)</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>假如我们对数组中包含哪些元素并不了解，只是想知道其中是否含有元素 “E”，数组会如何查找元素 &#96;”E” 呢？</p><p>​    与读取元素类似，由于我们只保存了索引为 0 处的内存地址，因此在查找元素时，只需从数组开头逐步向后查找就可以了。如果数组中的某个元素为目标元素，则停止查找；否则继续搜索直到到达数组的末尾<img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163045.png" alt="4.gif"></p><p>发现，最坏情况下，搜索的元素为 “R”，或者数组中不包含目标元素时，我们需要查找 n 次，n 为数组的长度，因此查找元素的时间复杂度为 O(N)</p><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>假如我们想在原有的数组中再插入一个元素 “S” 呢？</p><p>​    如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。<img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163222.png" alt="6.gif"></p><p>​    然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置 腾出 空间，然后进行插入操作。比如，我们想要在索引 2 处插入 “S”。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163431.png" alt="7.gif"></p><p>​    发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一种数据结构，即链表可以有效解决这个问题。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>​    删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 空缺 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 填补 操作。</p><p>以删除索引 1 中的元素 “O” 为例，具体过程如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163536.png" alt="6.gif"></p><p>​    当数组的长度为 n 时，最坏情况下，我们删除第一个元素，共需要的步骤数为 1 + (n - 1) &#x3D; n 步，其中，1 为删除操作，n - 1 为移动其余元素的步骤数。删除操作具有线性时间复杂度，即时间复杂度为 O(N)，N 为数组的长度。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>​    二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164440.png"></p><p>所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 <code>0</code> 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题</p><p>类似一维数组，对于一个二维数组 A &#x3D; [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]，计算机同样会在内存中申请一段 连续 的空间，并记录第一行数组的索引位置，即 A[0][0] 的内存地址，它的索引与内存地址的关系如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164553.png"></p><h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><h3 id="为何单独讨论字符串类型"><a href="#为何单独讨论字符串类型" class="headerlink" title="为何单独讨论字符串类型"></a>为何单独讨论字符串类型</h3><p>我们知道，字符串与数组有很多相似之处，比如使用 名称[下标] 来得到一个字符。那么我们为什么要单独讨论字符串呢？原因主要有：</p><ol><li>字符串的基本操作对象通常是字符串整体或者其子串</li></ol><p>例如有这样一个字符串序列：I like leetcode 现在你想把这句话反向输出，可能会变成这样：edocteel ekil I</p><p>这是我们想要的结果吗？你可能会回答不是，因为它没有任何意义。我们通常希望单词仍然维持原来的顺序，这样反向输出之后就是：Leetcode like I</p><p>这样的结果对于我们来讲是不是更满意呢？维持单词本身的顺序使得我们方便进行更多操作，这里的每个单词就叫做字符串的「子串」，通常，我们的操作对象更多情况下是这些子串。</p><ol start="2"><li>字符串操作比其他数据类型更复杂（例如比较、连接操作）</li></ol><p>对于不同的编程语言，字符串的某些操作会有所不同。下面我们将从字符串的「比较」和「连接」操作两个方面分别进行讲解。</p><h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><p>字符串有它自己的比较函数（我们将在下面的代码中向你展示比较函数的用法）。</p><p>然而，存在这样一个问题：</p><p>我们可以用 “&#x3D;&#x3D;” 来比较两个字符串吗？</p><p>这取决于下面这个问题的答案：</p><p>我们使用的语言是否支持运算符重载？</p><p>如果答案是 yes （例如 C++、Python）。我们可以使用 &#x3D;&#x3D; 来比较两个字符串；<br>如果答案是 no （例如 Java），我们可能无法使用 &#x3D;&#x3D; 来比较两个字符串。当我们使用 &#x3D;&#x3D; 时，它实际上会比较这两个对象是否是同一个对象</p><h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><p>对于不同的编程语言中，字符串可能是可变的，也可能是不可变的。不可变意味着一旦字符串被初始化，你就无法改变它的内容。</p><p>在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以像在数组中那样修改字符串。<br>在其他一些语言（如 Java、Python）中，字符串是不可变的。</p><p>在 <strong>字符串不可变</strong> 的语言中，进行字符串的连接操作则会带来一些问题。</p><p>显然，不可变字符串无法被修改。哪怕你只是想修改其中的一个字符，也必须创建一个新的字符串</p><p>针对 Java 中出现的此问题，我们提供了以下解决方案：</p><p>​    如果你确实希望你的字符串是可变的，则可以使用 toCharArray 将其转换为字符数组。<br>​    如果你经常必须连接字符串，最好使用一些其他的数据结构，如 StringBuilder 。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构-线性结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据库概述</title>
      <link href="/2022/03/27/MySQL%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/03/27/MySQL%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础-数据库概述"><a href="#MySQL基础-数据库概述" class="headerlink" title="MySQL基础-数据库概述"></a>MySQL基础-数据库概述</h1><h2 id="为什么用数据库"><a href="#为什么用数据库" class="headerlink" title="为什么用数据库"></a>为什么用数据库</h2><ol><li><p>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企</p><p>业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多</p><p>通过各种关系数据库来完成。</p></li><li><p>持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数</p><p>据文件中。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328120129.png" alt="数据库展示"></p><h2 id="数据库与数据库管理系统"><a href="#数据库与数据库管理系统" class="headerlink" title="数据库与数据库管理系统"></a>数据库与数据库管理系统</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="DB：数据库（Database）"><a href="#DB：数据库（Database）" class="headerlink" title="DB：数据库（Database）"></a>DB：数据库（Database）</h4><p>​    存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</p><h4 id="DBMS：数据库管理系统（Database-Management-System）"><a href="#DBMS：数据库管理系统（Database-Management-System）" class="headerlink" title="DBMS：数据库管理系统（Database Management System）"></a>DBMS：数据库管理系统（Database Management System）</h4><p>​    是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控</p><p>制。用户通过数据库管理系统访问数据库中表内的数据。</p><h4 id="SQL：结构化查询语言（Structured-Query-Language）"><a href="#SQL：结构化查询语言（Structured-Query-Language）" class="headerlink" title="SQL：结构化查询语言（Structured Query Language）"></a>SQL：结构化查询语言（Structured Query Language）</h4><p>​    专门用来与数据库通信的语言。</p><h3 id="数据库与数据库管理系统的关系"><a href="#数据库与数据库管理系统的关系" class="headerlink" title="数据库与数据库管理系统的关系"></a>数据库与数据库管理系统的关系</h3><p>​    数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存</p><p>应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p><p>数据库管理系统、数据库和表的关系如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328120706.png" alt="关系图"></p><h3 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h3><h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><p>1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气</p><p>越来越大，公司也改名叫 Oracle 公司。</p><p>2007年，总计85亿美金收购BEA Systems。 </p><p>2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了</p><p>MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。</p><p>2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。</p><p>如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。</p><h4 id="SQLserver"><a href="#SQLserver" class="headerlink" title="SQLserver"></a>SQLserver</h4><p>SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集</p><p>成，也可以很好地与Microsoft BackOffice产品集成。</p><h4 id="DB-2"><a href="#DB-2" class="headerlink" title="DB 2"></a>DB 2</h4><p>IBM公司的数据库产品,收费的。常应用在银行系统中。</p><h4 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h4><p>PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以</p><p>及SQL处理较快。</p><h4 id="SQlite"><a href="#SQlite" class="headerlink" title="SQlite"></a>SQlite</h4><p>嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置</p><p>数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。</p><h4 id="informix"><a href="#informix" class="headerlink" title="informix"></a>informix</h4><p>IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行</p><p>于unix&#x2F;linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证</p><p>券系统的应用。</p><h2 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h2><p>MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着</p><p>应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、</p><p>易维护、易扩展的需求，促进了MySQL的长足发展。</p><h3 id="MySQL8-0"><a href="#MySQL8-0" class="headerlink" title="MySQL8.0"></a>MySQL8.0</h3><p>MySQL从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上</p><p>做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化</p><p>器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><h3 id="选择MySQL原因"><a href="#选择MySQL原因" class="headerlink" title="选择MySQL原因"></a>选择MySQL原因</h3><ol><li>开放源代码，使用成本低。</li><li>性能卓越，服务稳定。</li><li>软件体积小，使用简单，并且易于维护。</li><li>历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。</li><li>许多互联网公司在用，经过了时间的验证。</li></ol><h2 id="RDBMS-与-非RDBMS"><a href="#RDBMS-与-非RDBMS" class="headerlink" title="RDBMS 与 非RDBMS"></a>RDBMS 与 非RDBMS</h2><p>关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、 </p><p>MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。</p><h3 id="关系型数据库-RDBMS"><a href="#关系型数据库-RDBMS" class="headerlink" title="关系型数据库(RDBMS)"></a>关系型数据库(RDBMS)</h3><p>​    这种类型的数据库是 最古老 的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系 （即二维表格形式）。</p><p>​    关系型数据库以 行(row) 和 列(column) 的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table) ，一组表组成了一个库(database)</p><p>​    SQL 就是关系型数据库的查询语言。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328122134.png"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>复杂查询 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>事务支持 使得对于安全性能很高的数据访问要求得以实现。</li></ol><h3 id="非关系型数据库-非RDBMS"><a href="#非关系型数据库-非RDBMS" class="headerlink" title="非关系型数据库(非RDBMS)"></a>非关系型数据库(非RDBMS)</h3><p>​    非关系型数据库，可看成传统关系型数据库的功能 阉割版本 ，基于键值对存储数据，不需要经过SQL层的解析， 性能非常高 。同时，通过减少不常用的功能，进一步提高性能。</p><p>​    目前基本上大部分主流的非关系型数据库都是免费的。</p><h4 id="键值型数据库"><a href="#键值型数据库" class="headerlink" title="键值型数据库"></a>键值型数据库</h4><p>​    键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。</p><p>​    键值型数据库典型的使用场景是作为 内存缓存 。 Redis 是最流行的键值型数据库。</p><h4 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h4><p>​    此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB是最流行的文档型数据库。此外，还有CouchDB等。</p><h4 id="搜索引擎数据库"><a href="#搜索引擎数据库" class="headerlink" title="搜索引擎数据库"></a>搜索引擎数据库</h4><p>​    虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。</p><p>典型产品：Solr、Elasticsearch、Splunk 等。</p><h4 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h4><p>​    列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I&#x2F;O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</p><h4 id="图形数据库"><a href="#图形数据库" class="headerlink" title="图形数据库"></a>图形数据库</h4><p>​    图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p><p>​    图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。</p><h2 id="关系型数据库涉及规则"><a href="#关系型数据库涉及规则" class="headerlink" title="关系型数据库涉及规则"></a>关系型数据库涉及规则</h2><ol><li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。</li></ol><h3 id="表、记录、字段"><a href="#表、记录、字段" class="headerlink" title="表、记录、字段"></a>表、记录、字段</h3><ol><li>E-R（entity-relationship，实体-联系）模型中有三个主要概念是： 实体集 、 属性 、 联系集 。</li><li>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328123020.png"></p><h3 id="表的关联关系"><a href="#表的关联关系" class="headerlink" title="表的关联关系"></a>表的关联关系</h3><ol><li><p>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用</p><p>关系模型来表示。</p></li><li><p>四种：一对一关联、一对多关联、多对多关联、自我引用.</p><p></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法--稀疏数组</title>
      <link href="/2022/03/27/%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/27/%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="算法-–稀疏数组"><a href="#算法-–稀疏数组" class="headerlink" title="算法 –稀疏数组"></a>算法 –稀疏数组</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>编写五子棋盘，实现IO存盘，可以将数据写入到存盘中（IO读写不实操）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>五子棋盘可以转化为二维数组，0 代表空位 1代表白棋，2 代表黑棋</li><li>二维数组中存在大量 0 ，这是无意义数据，所以采用稀疏数组进行压缩</li><li>稀疏数组压缩好处，减小存储，减少IO，提高效率</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327150042.png" alt="稀疏数组"></p><p>准备：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建原始数组</span></span><br><span class="line">      <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">      <span class="comment">// 有效数据</span></span><br><span class="line">      arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">      arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">      arr[<span class="number">3</span>][<span class="number">4</span>] =<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span>[] ints : arr) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">              System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327152959.png" alt="棋盘数组"></p><h3 id="二维数组转换为稀疏数组"><a href="#二维数组转换为稀疏数组" class="headerlink" title="二维数组转换为稀疏数组"></a>二维数组转换为稀疏数组</h3><p>思路：</p><ol><li>遍历原始数组得到有效数据个数sum。</li><li>根据sum创建稀疏数组大小</li><li>将有效数据存入到稀疏数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建稀疏数组</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1.先遍历二维数组，得到非零数据的个数</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) sum ++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.创建稀疏数组</span></span><br><span class="line">     <span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">     <span class="comment">// 记录原数组初始规模,有效数据个数</span></span><br><span class="line">     sparseArr[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">     sparseArr[<span class="number">0</span>][<span class="number">1</span>] = arr.length;</span><br><span class="line">     sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     flag:</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                 count ++;</span><br><span class="line">                 sparseArr[count][<span class="number">0</span>] =i;</span><br><span class="line">                 sparseArr[count][<span class="number">1</span>] =j;</span><br><span class="line">                 sparseArr[count][<span class="number">2</span>] =arr[i][j];</span><br><span class="line">                 <span class="keyword">if</span> (count == (sum + <span class="number">1</span>))&#123;</span><br><span class="line">                     <span class="keyword">break</span> flag;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327153156.png" alt="稀疏数组"></p><h3 id="稀疏数组转化为原始数组"><a href="#稀疏数组转化为原始数组" class="headerlink" title="稀疏数组转化为原始数组"></a>稀疏数组转化为原始数组</h3><p>思路：</p><ol><li>先读取稀疏数组第一行，根据第一行数据，创建原始二维数组</li><li>在读取稀疏数组后几行数据，并赋给原始数组对应位置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏数组转换为原始数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据稀疏数组第一行创建原始数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把数据还原到chessArr</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327154153.png" alt="还原棋盘数组"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原始数组</span></span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        <span class="comment">// 有效数据</span></span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">4</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建稀疏数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.先遍历二维数组，得到非零数据的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) sum ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.创建稀疏数组</span></span><br><span class="line">        <span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 记录原数组初始规模,有效数据个数</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = arr.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        flag:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] =i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] =j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] =arr[i][j];</span><br><span class="line">                    <span class="keyword">if</span> (count == (sum + <span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">break</span> flag;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出得到的稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.println(sparseArr[i][<span class="number">0</span>] + <span class="string">&quot;\t&quot;</span> + sparseArr[i][<span class="number">1</span>] + <span class="string">&quot;\t&quot;</span> + sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稀疏数组转换为原始数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据稀疏数组第一行创建原始数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把数据还原到chessArr</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出还原后的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个文章</title>
      <link href="/2022/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/"/>
      <url>/2022/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h1><p>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊</p><h2 id="dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊"><a href="#dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊" class="headerlink" title="dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊"></a>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊</h2><p>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊</p><h3 id="fawejk"><a href="#fawejk" class="headerlink" title="fawejk"></a>fawejk</h3>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/26/hello-world/"/>
      <url>/2022/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
