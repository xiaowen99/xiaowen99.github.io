<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL第九章--子查询</title>
      <link href="/2022/03/28/MySQL%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/03/28/MySQL%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="第九章–子查询"><a href="#第九章–子查询" class="headerlink" title="第九章–子查询"></a>第九章–子查询</h1><p>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。</p><p>SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p><h2 id="需求分析和问题解决"><a href="#需求分析和问题解决" class="headerlink" title="需求分析和问题解决"></a>需求分析和问题解决</h2><h3 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328185428.png" alt="1"></p><p>现有解决方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#方式一： </span><br><span class="line">SELECT salary </span><br><span class="line">FROM employees </span><br><span class="line">WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT last_name,salary </span><br><span class="line">FROM employees </span><br><span class="line">WHERE salary &gt; 11000; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#方式二：自连接 </span><br><span class="line">SELECT e2.last_name,e2.salary </span><br><span class="line">FROM employees e1,employees e2 </span><br><span class="line">WHERE e1.last_name = &#x27;Abel&#x27; </span><br><span class="line">AND e1.`salary` &lt; e2.`salary`</span><br><span class="line"></span><br><span class="line">#方式三：子查询</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name =&#x27;Abel&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="子查询的基本使用"><a href="#子查询的基本使用" class="headerlink" title="子查询的基本使用"></a>子查询的基本使用</h3><h4 id="子查询的基本语法结构："><a href="#子查询的基本语法结构：" class="headerlink" title="子查询的基本语法结构："></a>子查询的基本语法结构：</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328191316.png" alt="1"></p><p>子查询（内查询）在主查询之前一次执行完成。</p><p>子查询的结果被主查询（外查询）使用。</p><p><strong>注意事项</strong></p><ol><li>子查询要包含在括号内</li><li>将子查询放在比较条件的右侧</li><li>单行操作符对应单行子查询，多行操作符对应多行子查询</li></ol><h3 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h3><h4 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328192609.png"></p><p>查询出一个结果供外查询使用</p><h4 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328192749.png"></p><p>查询出多个结果供给外查询使用</p><h4 id="相关（关联）子查询"><a href="#相关（关联）子查询" class="headerlink" title="相关（关联）子查询"></a>相关（关联）子查询</h4><h4 id="不相关（或非关联）子查询"><a href="#不相关（或非关联）子查询" class="headerlink" title="不相关（或非关联）子查询"></a>不相关（或非关联）子查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name =&#x27;Abel&#x27;</span><br><span class="line">);</span><br><span class="line"># 外查询每次查询都只跟内查询的查询结果做比较，内查询的查询结果就只需要查询一次，这就是一次非关联子查询</span><br></pre></td></tr></table></figure><h2 id="单行子查询-1"><a href="#单行子查询-1" class="headerlink" title="单行子查询"></a>单行子查询</h2><h3 id="单行子查询比较操作符"><a href="#单行子查询比较操作符" class="headerlink" title="单行子查询比较操作符"></a>单行子查询比较操作符</h3><table><thead><tr><th align="center">操作符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">equal to</td></tr><tr><td align="center">&gt;</td><td align="center">greater than</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">greater than or equal to</td></tr><tr><td align="center">&lt;</td><td align="center">less than</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">less than or equal to</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">not equal to</td></tr></tbody></table><h3 id="例子代码示范"><a href="#例子代码示范" class="headerlink" title="例子代码示范"></a>例子代码示范</h3><h4 id="题目：查询工资大于149号员工工资的员工的信息"><a href="#题目：查询工资大于149号员工工资的员工的信息" class="headerlink" title="题目：查询工资大于149号员工工资的员工的信息"></a>题目：查询工资大于149号员工工资的员工的信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">                SELECT salary</span><br><span class="line">                FROM employees</span><br><span class="line">                WHERE employee_id = 149</span><br><span class="line">                );</span><br></pre></td></tr></table></figure><h4 id="题目：返回job-id与141号员工相同，salary比143号员工多的员工姓名，job-id和工资"><a href="#题目：返回job-id与141号员工相同，salary比143号员工多的员工姓名，job-id和工资" class="headerlink" title="题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资"></a>题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary = (</span><br><span class="line">              SELECT MIN(salary)</span><br><span class="line">              FROM employees</span><br><span class="line">             );</span><br></pre></td></tr></table></figure><h4 id="题目：-HAVNING语句中-查询最低工资大于50号部门最低工资的部门id和其最低工资"><a href="#题目：-HAVNING语句中-查询最低工资大于50号部门最低工资的部门id和其最低工资" class="headerlink" title="题目：(HAVNING语句中)查询最低工资大于50号部门最低工资的部门id和其最低工资"></a>题目：(HAVNING语句中)查询最低工资大于50号部门最低工资的部门id和其最低工资</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id, MIN(salary) </span><br><span class="line">FROM employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">HAVING MIN(salary) &gt; (</span><br><span class="line">                      SELECT MIN(salary) </span><br><span class="line">  FROM employees </span><br><span class="line">  WHERE department_id = 50</span><br><span class="line">                      );</span><br></pre></td></tr></table></figure><h4 id="题目：-case中-显式员工的employee-id-last-name和location。其中，若员工department-id与location-id为1800的department-id相同，则location为’Canada’，其余则为’USA’。"><a href="#题目：-case中-显式员工的employee-id-last-name和location。其中，若员工department-id与location-id为1800的department-id相同，则location为’Canada’，其余则为’USA’。" class="headerlink" title="题目：(case中)显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。"></a>题目：(case中)显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id, last_name, (CASE department_id WHEN (SELECT department_id FROM departments WHERE location_id = 1800) THEN &#x27;Canada&#x27; ELSE &#x27;USA&#x27; END) location FROM employees;</span><br></pre></td></tr></table></figure><h4 id="题目：子查询中的空值问题"><a href="#题目：子查询中的空值问题" class="headerlink" title="题目：子查询中的空值问题"></a>题目：子查询中的空值问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, job_id </span><br><span class="line">FROM employees </span><br><span class="line">WHERE job_id = (</span><br><span class="line">              SELECT job_id </span><br><span class="line">              FROM employees </span><br><span class="line">              WHERE last_name = &#x27;Haas&#x27;</span><br><span class="line">              );</span><br><span class="line"># 子查询结果为null，所以跟主查询任何值跟null比较都为null，所以没有数据</span><br></pre></td></tr></table></figure><h2 id="多行子查询-1"><a href="#多行子查询-1" class="headerlink" title="多行子查询"></a>多行子查询</h2><p>也称为集合比较子查询</p><p>内查询返回多行</p><p>使用多行比较操作符</p><h3 id="多行子查询操作符"><a href="#多行子查询操作符" class="headerlink" title="多行子查询操作符"></a>多行子查询操作符</h3><table><thead><tr><th align="center">操作符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">IN</td><td align="center">等于列表中的任意一个</td></tr><tr><td align="center">ANY</td><td align="center">需要和单行比较操作符一起使用，和子查询返回的某一个值比较</td></tr><tr><td align="center">ALL</td><td align="center">需要和单行比较操作符一起使用，和子查询返回的所有值比较</td></tr><tr><td align="center">SOME</td><td align="center">实际上是ANY的别名，作用相同，一般常使用ANY</td></tr></tbody></table><h3 id="例子代码示范-1"><a href="#例子代码示范-1" class="headerlink" title="例子代码示范"></a>例子代码示范</h3><h4 id="题目：返回其它job-id中比job-id为‘IT-PROG’部门任一工资低的员工的员工号、姓名、job-id-以及salary"><a href="#题目：返回其它job-id中比job-id为‘IT-PROG’部门任一工资低的员工的员工号、姓名、job-id-以及salary" class="headerlink" title="题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary"></a>题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &lt; ANY(</span><br><span class="line">                  SELECT salary</span><br><span class="line">                  FROM employees</span><br><span class="line">                  WHERE job_id = &#x27;IT_PROG&#x27;</span><br><span class="line">                  )</span><br><span class="line">AND job_id &lt;&gt; &#x27;IT_PROG&#x27;;</span><br></pre></td></tr></table></figure><h4 id="题目：返回其它job-id中比job-id为‘IT-PROG’部门所有工资低的员工的员工号、姓名、job-id-以及salary"><a href="#题目：返回其它job-id中比job-id为‘IT-PROG’部门所有工资低的员工的员工号、姓名、job-id-以及salary" class="headerlink" title="题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资低的员工的员工号、姓名、job_id 以及salary"></a>题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资低的员工的员工号、姓名、job_id 以及salary</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name,job_id,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &lt; ALL(</span><br><span class="line">                  SELECT salary</span><br><span class="line">                  FROM employees</span><br><span class="line">                  WHERE job_id = &#x27;IT_PROG&#x27;</span><br><span class="line">                  )</span><br><span class="line">AND job_id &lt;&gt; &#x27;IT_PROG&#x27;;</span><br></pre></td></tr></table></figure><h4 id="题目：查询平均工资最低的部门id"><a href="#题目：查询平均工资最低的部门id" class="headerlink" title="题目：查询平均工资最低的部门id"></a>题目：查询平均工资最低的部门id</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) = (</span><br><span class="line">                      SELECT MIN(avg_sal)</span><br><span class="line">                      FROM (</span><br><span class="line">                            SELECT AVG(salary) avg_sal</span><br><span class="line">                            FROM employees</span><br><span class="line">                            GROUP BY department_id</span><br><span class="line">                            ) dept_avg_sal</span><br><span class="line">);</span><br><span class="line"># from 后面写子查询，相当于重新建了一张表，表只有一列数据，只有一个字段 avg_sal</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) &lt;=ALL(</span><br><span class="line">                        SELECT AVG(salary) avg_sal</span><br><span class="line">                        FROM employees</span><br><span class="line">                        GROUP BY department_id</span><br><span class="line">                        );</span><br></pre></td></tr></table></figure><h4 id="题目：多查询中的空值问题"><a href="#题目：多查询中的空值问题" class="headerlink" title="题目：多查询中的空值问题"></a>题目：多查询中的空值问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name </span><br><span class="line">FROM employees </span><br><span class="line">WHERE employee_id NOT IN ( </span><br><span class="line">                          SELECT manager_id </span><br><span class="line">                          FROM employees </span><br><span class="line">                          );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题--搜索插入位置</title>
      <link href="/2022/03/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2022/03/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题--寻找数组的中心索引</title>
      <link href="/2022/03/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/03/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="寻找数组中心索引"><a href="#寻找数组中心索引" class="headerlink" title="寻找数组中心索引"></a>寻找数组中心索引</h1><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p><p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum - nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            <span class="keyword">if</span> (leftNum == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            leftNum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性结构-数组</title>
      <link href="/2022/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-线性结构-数组"><a href="#数据结构-线性结构-数组" class="headerlink" title="数据结构-线性结构-数组"></a>数据结构-线性结构-数组</h1><h2 id="集合、列表、数组定义"><a href="#集合、列表、数组定义" class="headerlink" title="集合、列表、数组定义"></a>集合、列表、数组定义</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>​    由一个或多个确定的元素所构成的整体。通俗来讲，集合就是将一组事物组合在一起。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>集合里的元素类型不一定相同</li><li>集合里的元素没有顺序</li></ol><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>​    是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。</p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ol><li>有限</li><li>有序</li><li>长度可变</li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>​    数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。</p><p>​    正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的一些特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如 C++ 和 Java 中，数组中的元素类型必须保持一致，而 Python 中则可以不同。Python 中的数组叫做 list，具有更多的高级功能。</p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>​    数组会用一些名为 <code>索引</code> 的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 <code>0</code> 算起的。我们可以根据数组中的索引，快速访问数组中的元素。<img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163908.png" alt="4.png"></p><p>​    而列表中没有索引，这是数组与列表最大的不同点。</p><p>​    其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。要理解这一点，我们需要了解数组在内存中的存储方式，我们将在下一节中详细介绍。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163941.png" alt="5.png"></p><p>​    相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。</p><h2 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h2><h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><p>​    读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 0 开始。</p><p>​    在计算机中，内存可以看成一些已经排列好的格子，每个格子对应一个内存地址。一般情况下，数据会分散地存储在不同的格子中。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164026.png" alt="1.png"></p><p>​    而对于数组，计算机会在内存中为其申请一段 连续 的空间，并且会记下索引为 0 处的内存地址。以数组 [“C”, “O”, “D”, “E”, “R”] 为例，它的各元素对应的索引及内存地址如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164054.png" alt="2.png"></p><p>假如我们想要访问索引为 2 处的元素 “D” 时，计算机会进行以下计算：</p><ol><li>找到该数组的索引 0 的内存地址： 2008；</li><li>将内存地址加上索引值，作为目标元素的地址，即 2008 + 2 &#x3D; 2010，对应的元素为 “D”，这时便找到了目标元素。</li></ol><p>我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 O(1)</p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>假如我们对数组中包含哪些元素并不了解，只是想知道其中是否含有元素 “E”，数组会如何查找元素 &#96;”E” 呢？</p><p>​    与读取元素类似，由于我们只保存了索引为 0 处的内存地址，因此在查找元素时，只需从数组开头逐步向后查找就可以了。如果数组中的某个元素为目标元素，则停止查找；否则继续搜索直到到达数组的末尾<img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163045.png" alt="4.gif"></p><p>发现，最坏情况下，搜索的元素为 “R”，或者数组中不包含目标元素时，我们需要查找 n 次，n 为数组的长度，因此查找元素的时间复杂度为 O(N)</p><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>假如我们想在原有的数组中再插入一个元素 “S” 呢？</p><p>​    如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。<img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163222.png" alt="6.gif"></p><p>​    然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置 腾出 空间，然后进行插入操作。比如，我们想要在索引 2 处插入 “S”。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163431.png" alt="7.gif"></p><p>​    发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一种数据结构，即链表可以有效解决这个问题。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>​    删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 空缺 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 填补 操作。</p><p>以删除索引 1 中的元素 “O” 为例，具体过程如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328163536.png" alt="6.gif"></p><p>​    当数组的长度为 n 时，最坏情况下，我们删除第一个元素，共需要的步骤数为 1 + (n - 1) &#x3D; n 步，其中，1 为删除操作，n - 1 为移动其余元素的步骤数。删除操作具有线性时间复杂度，即时间复杂度为 O(N)，N 为数组的长度。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>​    二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164440.png"></p><p>所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 <code>0</code> 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题</p><p>类似一维数组，对于一个二维数组 A &#x3D; [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]，计算机同样会在内存中申请一段 连续 的空间，并记录第一行数组的索引位置，即 A[0][0] 的内存地址，它的索引与内存地址的关系如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328164553.png"></p><h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><h3 id="为何单独讨论字符串类型"><a href="#为何单独讨论字符串类型" class="headerlink" title="为何单独讨论字符串类型"></a>为何单独讨论字符串类型</h3><p>我们知道，字符串与数组有很多相似之处，比如使用 名称[下标] 来得到一个字符。那么我们为什么要单独讨论字符串呢？原因主要有：</p><ol><li>字符串的基本操作对象通常是字符串整体或者其子串</li></ol><p>例如有这样一个字符串序列：I like leetcode 现在你想把这句话反向输出，可能会变成这样：edocteel ekil I</p><p>这是我们想要的结果吗？你可能会回答不是，因为它没有任何意义。我们通常希望单词仍然维持原来的顺序，这样反向输出之后就是：Leetcode like I</p><p>这样的结果对于我们来讲是不是更满意呢？维持单词本身的顺序使得我们方便进行更多操作，这里的每个单词就叫做字符串的「子串」，通常，我们的操作对象更多情况下是这些子串。</p><ol start="2"><li>字符串操作比其他数据类型更复杂（例如比较、连接操作）</li></ol><p>对于不同的编程语言，字符串的某些操作会有所不同。下面我们将从字符串的「比较」和「连接」操作两个方面分别进行讲解。</p><h3 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h3><p>字符串有它自己的比较函数（我们将在下面的代码中向你展示比较函数的用法）。</p><p>然而，存在这样一个问题：</p><p>我们可以用 “&#x3D;&#x3D;” 来比较两个字符串吗？</p><p>这取决于下面这个问题的答案：</p><p>我们使用的语言是否支持运算符重载？</p><p>如果答案是 yes （例如 C++、Python）。我们可以使用 &#x3D;&#x3D; 来比较两个字符串；<br>如果答案是 no （例如 Java），我们可能无法使用 &#x3D;&#x3D; 来比较两个字符串。当我们使用 &#x3D;&#x3D; 时，它实际上会比较这两个对象是否是同一个对象</p><h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><p>对于不同的编程语言中，字符串可能是可变的，也可能是不可变的。不可变意味着一旦字符串被初始化，你就无法改变它的内容。</p><p>在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以像在数组中那样修改字符串。<br>在其他一些语言（如 Java、Python）中，字符串是不可变的。</p><p>在 <strong>字符串不可变</strong> 的语言中，进行字符串的连接操作则会带来一些问题。</p><p>显然，不可变字符串无法被修改。哪怕你只是想修改其中的一个字符，也必须创建一个新的字符串</p><p>针对 Java 中出现的此问题，我们提供了以下解决方案：</p><p>​    如果你确实希望你的字符串是可变的，则可以使用 toCharArray 将其转换为字符数组。<br>​    如果你经常必须连接字符串，最好使用一些其他的数据结构，如 StringBuilder 。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构-线性结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据库概述</title>
      <link href="/2022/03/27/MySQL%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/03/27/MySQL%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础-数据库概述"><a href="#MySQL基础-数据库概述" class="headerlink" title="MySQL基础-数据库概述"></a>MySQL基础-数据库概述</h1><h2 id="为什么用数据库"><a href="#为什么用数据库" class="headerlink" title="为什么用数据库"></a>为什么用数据库</h2><ol><li><p>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企</p><p>业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多</p><p>通过各种关系数据库来完成。</p></li><li><p>持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数</p><p>据文件中。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328120129.png" alt="数据库展示"></p><h2 id="数据库与数据库管理系统"><a href="#数据库与数据库管理系统" class="headerlink" title="数据库与数据库管理系统"></a>数据库与数据库管理系统</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="DB：数据库（Database）"><a href="#DB：数据库（Database）" class="headerlink" title="DB：数据库（Database）"></a>DB：数据库（Database）</h4><p>​    存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</p><h4 id="DBMS：数据库管理系统（Database-Management-System）"><a href="#DBMS：数据库管理系统（Database-Management-System）" class="headerlink" title="DBMS：数据库管理系统（Database Management System）"></a>DBMS：数据库管理系统（Database Management System）</h4><p>​    是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控</p><p>制。用户通过数据库管理系统访问数据库中表内的数据。</p><h4 id="SQL：结构化查询语言（Structured-Query-Language）"><a href="#SQL：结构化查询语言（Structured-Query-Language）" class="headerlink" title="SQL：结构化查询语言（Structured Query Language）"></a>SQL：结构化查询语言（Structured Query Language）</h4><p>​    专门用来与数据库通信的语言。</p><h3 id="数据库与数据库管理系统的关系"><a href="#数据库与数据库管理系统的关系" class="headerlink" title="数据库与数据库管理系统的关系"></a>数据库与数据库管理系统的关系</h3><p>​    数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存</p><p>应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p><p>数据库管理系统、数据库和表的关系如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328120706.png" alt="关系图"></p><h3 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h3><h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><p>1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气</p><p>越来越大，公司也改名叫 Oracle 公司。</p><p>2007年，总计85亿美金收购BEA Systems。 </p><p>2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了</p><p>MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。</p><p>2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。</p><p>如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。</p><h4 id="SQLserver"><a href="#SQLserver" class="headerlink" title="SQLserver"></a>SQLserver</h4><p>SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集</p><p>成，也可以很好地与Microsoft BackOffice产品集成。</p><h4 id="DB-2"><a href="#DB-2" class="headerlink" title="DB 2"></a>DB 2</h4><p>IBM公司的数据库产品,收费的。常应用在银行系统中。</p><h4 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h4><p>PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以</p><p>及SQL处理较快。</p><h4 id="SQlite"><a href="#SQlite" class="headerlink" title="SQlite"></a>SQlite</h4><p>嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置</p><p>数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。</p><h4 id="informix"><a href="#informix" class="headerlink" title="informix"></a>informix</h4><p>IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行</p><p>于unix&#x2F;linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证</p><p>券系统的应用。</p><h2 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h2><p>MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着</p><p>应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、</p><p>易维护、易扩展的需求，促进了MySQL的长足发展。</p><h3 id="MySQL8-0"><a href="#MySQL8-0" class="headerlink" title="MySQL8.0"></a>MySQL8.0</h3><p>MySQL从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上</p><p>做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化</p><p>器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><h3 id="选择MySQL原因"><a href="#选择MySQL原因" class="headerlink" title="选择MySQL原因"></a>选择MySQL原因</h3><ol><li>开放源代码，使用成本低。</li><li>性能卓越，服务稳定。</li><li>软件体积小，使用简单，并且易于维护。</li><li>历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。</li><li>许多互联网公司在用，经过了时间的验证。</li></ol><h2 id="RDBMS-与-非RDBMS"><a href="#RDBMS-与-非RDBMS" class="headerlink" title="RDBMS 与 非RDBMS"></a>RDBMS 与 非RDBMS</h2><p>关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、 </p><p>MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。</p><h3 id="关系型数据库-RDBMS"><a href="#关系型数据库-RDBMS" class="headerlink" title="关系型数据库(RDBMS)"></a>关系型数据库(RDBMS)</h3><p>​    这种类型的数据库是 最古老 的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系 （即二维表格形式）。</p><p>​    关系型数据库以 行(row) 和 列(column) 的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table) ，一组表组成了一个库(database)</p><p>​    SQL 就是关系型数据库的查询语言。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328122134.png"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>复杂查询 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>事务支持 使得对于安全性能很高的数据访问要求得以实现。</li></ol><h3 id="非关系型数据库-非RDBMS"><a href="#非关系型数据库-非RDBMS" class="headerlink" title="非关系型数据库(非RDBMS)"></a>非关系型数据库(非RDBMS)</h3><p>​    非关系型数据库，可看成传统关系型数据库的功能 阉割版本 ，基于键值对存储数据，不需要经过SQL层的解析， 性能非常高 。同时，通过减少不常用的功能，进一步提高性能。</p><p>​    目前基本上大部分主流的非关系型数据库都是免费的。</p><h4 id="键值型数据库"><a href="#键值型数据库" class="headerlink" title="键值型数据库"></a>键值型数据库</h4><p>​    键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。</p><p>​    键值型数据库典型的使用场景是作为 内存缓存 。 Redis 是最流行的键值型数据库。</p><h4 id="文档型数据库"><a href="#文档型数据库" class="headerlink" title="文档型数据库"></a>文档型数据库</h4><p>​    此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB是最流行的文档型数据库。此外，还有CouchDB等。</p><h4 id="搜索引擎数据库"><a href="#搜索引擎数据库" class="headerlink" title="搜索引擎数据库"></a>搜索引擎数据库</h4><p>​    虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。</p><p>典型产品：Solr、Elasticsearch、Splunk 等。</p><h4 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h4><p>​    列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I&#x2F;O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</p><h4 id="图形数据库"><a href="#图形数据库" class="headerlink" title="图形数据库"></a>图形数据库</h4><p>​    图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p><p>​    图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。</p><h2 id="关系型数据库涉及规则"><a href="#关系型数据库涉及规则" class="headerlink" title="关系型数据库涉及规则"></a>关系型数据库涉及规则</h2><ol><li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。</li></ol><h3 id="表、记录、字段"><a href="#表、记录、字段" class="headerlink" title="表、记录、字段"></a>表、记录、字段</h3><ol><li>E-R（entity-relationship，实体-联系）模型中有三个主要概念是： 实体集 、 属性 、 联系集 。</li><li>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220328123020.png"></p><h3 id="表的关联关系"><a href="#表的关联关系" class="headerlink" title="表的关联关系"></a>表的关联关系</h3><ol><li><p>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用</p><p>关系模型来表示。</p></li><li><p>四种：一对一关联、一对多关联、多对多关联、自我引用.</p><p></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法--稀疏数组</title>
      <link href="/2022/03/27/%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/27/%E7%AE%97%E6%B3%95-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="算法-–稀疏数组"><a href="#算法-–稀疏数组" class="headerlink" title="算法 –稀疏数组"></a>算法 –稀疏数组</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>编写五子棋盘，实现IO存盘，可以将数据写入到存盘中（IO读写不实操）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>五子棋盘可以转化为二维数组，0 代表空位 1代表白棋，2 代表黑棋</li><li>二维数组中存在大量 0 ，这是无意义数据，所以采用稀疏数组进行压缩</li><li>稀疏数组压缩好处，减小存储，减少IO，提高效率</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327150042.png" alt="稀疏数组"></p><p>准备：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建原始数组</span></span><br><span class="line">      <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">      <span class="comment">// 有效数据</span></span><br><span class="line">      arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">      arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">      arr[<span class="number">3</span>][<span class="number">4</span>] =<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span>[] ints : arr) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">              System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327152959.png" alt="棋盘数组"></p><h3 id="二维数组转换为稀疏数组"><a href="#二维数组转换为稀疏数组" class="headerlink" title="二维数组转换为稀疏数组"></a>二维数组转换为稀疏数组</h3><p>思路：</p><ol><li>遍历原始数组得到有效数据个数sum。</li><li>根据sum创建稀疏数组大小</li><li>将有效数据存入到稀疏数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建稀疏数组</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1.先遍历二维数组，得到非零数据的个数</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) sum ++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.创建稀疏数组</span></span><br><span class="line">     <span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">     <span class="comment">// 记录原数组初始规模,有效数据个数</span></span><br><span class="line">     sparseArr[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">     sparseArr[<span class="number">0</span>][<span class="number">1</span>] = arr.length;</span><br><span class="line">     sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     flag:</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                 count ++;</span><br><span class="line">                 sparseArr[count][<span class="number">0</span>] =i;</span><br><span class="line">                 sparseArr[count][<span class="number">1</span>] =j;</span><br><span class="line">                 sparseArr[count][<span class="number">2</span>] =arr[i][j];</span><br><span class="line">                 <span class="keyword">if</span> (count == (sum + <span class="number">1</span>))&#123;</span><br><span class="line">                     <span class="keyword">break</span> flag;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327153156.png" alt="稀疏数组"></p><h3 id="稀疏数组转化为原始数组"><a href="#稀疏数组转化为原始数组" class="headerlink" title="稀疏数组转化为原始数组"></a>稀疏数组转化为原始数组</h3><p>思路：</p><ol><li>先读取稀疏数组第一行，根据第一行数据，创建原始二维数组</li><li>在读取稀疏数组后几行数据，并赋给原始数组对应位置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稀疏数组转换为原始数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据稀疏数组第一行创建原始数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把数据还原到chessArr</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaowen99/picdemo/img/20220327154153.png" alt="还原棋盘数组"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原始数组</span></span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        <span class="comment">// 有效数据</span></span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">4</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建稀疏数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.先遍历二维数组，得到非零数据的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) sum ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.创建稀疏数组</span></span><br><span class="line">        <span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 记录原数组初始规模,有效数据个数</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = arr.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        flag:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] =i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] =j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] =arr[i][j];</span><br><span class="line">                    <span class="keyword">if</span> (count == (sum + <span class="number">1</span>))&#123;</span><br><span class="line">                        <span class="keyword">break</span> flag;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出得到的稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.println(sparseArr[i][<span class="number">0</span>] + <span class="string">&quot;\t&quot;</span> + sparseArr[i][<span class="number">1</span>] + <span class="string">&quot;\t&quot;</span> + sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稀疏数组转换为原始数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 根据稀疏数组第一行创建原始数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把数据还原到chessArr</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出还原后的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : chessArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个文章</title>
      <link href="/2022/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/"/>
      <url>/2022/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h1><p>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊</p><h2 id="dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊"><a href="#dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊" class="headerlink" title="dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊"></a>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊</h2><p>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊<br>dfawefgsaefwdffsfsdfsdafaa啊啊啊啊啊啊啊啊啊</p><h3 id="fawejk"><a href="#fawejk" class="headerlink" title="fawejk"></a>fawejk</h3>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/26/hello-world/"/>
      <url>/2022/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
